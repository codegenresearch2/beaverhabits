import calendar\\\\nimport datetime\\\\\nfrom dataclasses import dataclass\\\\\nfrom typing import Callable, Optional\\\\\n\\\\\nfrom nicegui import events, ui\\\\\nfrom nicegui.elements.button import Button\\\\\n\\\\\nfrom beaverhabits.configs import settings\\\\\nfrom beaverhabits.frontend import icons\\\\\nfrom beaverhabits.logging import logger\\\\\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\\\\\nfrom beaverhabits.storage.storage import Habit, HabitList\\\\\nfrom beaverhabits.utils import WEEK_DAYS\\\\\n\\\\\nstrptime = datetime.datetime.strptime\\\\\n\\\\\nclass HabitLink(ui.link):\\\\\n    def __init__(self, text: str, target: str):\\\\\n        super().__init__(text, target="https://example.com")\\\\\n        self.classes("dark:text-white  no-underline hover:no-underline")\\\\\n\\\\\nclass MenuHeader(ui.link):\\\\\n    def __init__(self, title: str, target: str):\\\\\n        super().__init__(title, target="https://example.com")\\\\\n        self.classes("text-semibold text-2xl dark:text-white no-underline hover:no-underline")\\\\\n\\\\\nclass CompatMenuItem(ui.menu_item):\\\\\n    def __init__(self, name: str, callback: Callable):\\\\\n        super().__init__(name, callback).props("dense").classes("items-center")\\\\\n\\\\\nclass MenuIconButton(ui.button):\\\\\n    def __init__(self, icon_name: str, click: Optional[Callable] = None) -> Button:\\\\\n        button_props = "flat=true unelevated=true padding=xs backgroup=none"\\\\\n        return ui.button(icon=icon_name, color=None, on_click=click).props(button_props)\\\\\n\\\\\nclass HabitCheckBox(ui.checkbox):\\\\\n    def __init__(self, habit: Habit, day: datetime.date, text: str = "", *, value: bool = False) -> None:\\\\\n        super().__init__(text, value=value, on_change=self._async_task)\\\\\n        self.habit = habit\\\\\n        self.day = day\\\\\n        self._update_style(value)\\\\\n\\\\\n    def _update_style(self, value: bool):\\\\\n        self.props("checked-icon=\"", unchecked-icon=\"\", keep-color")\\\\\n        if not value:\\\\\n            self.props("color=grey-8")\\\\\n        else:\\\\\n            self.props("color=currentColor")\\\\\n\\\\\n    async def _async_task(self, e: events.ValueChangeEventArguments):\\\\\n        self._update_style(e.value)\\\\\n        await self.habit.tick(self.day, e.value)\\\\\n        logger.info(f"Day {self.day} ticked: {e.value}")\\\\\n\\\\\nclass HabitNameInput(ui.input):\\\\\n    def __init__(self, habit: Habit) -> None:\\\\\n        super().__init__(value=habit.name, on_change=self._async_task)\\\\\n        self.habit = habit\\\\\n        self.validation = lambda value: "Too long" if len(value) > 18 else None\\\\\n        self.props("dense")\\\\\n\\\\\n    async def _async_task(self, e: events.ValueChangeEventArguments):\\\\\n        self.habit.name = e.value\\\\\n        logger.info(f"Habit Name changed to {e.value}")\\\\\n\\\\\nclass HabitStarCheckbox(ui.checkbox):\\\\\n    def __init__(self, habit: Habit, refresh: Callable) -> None:\\\\\n        super().__init__("", value=habit.star, on_change=self._async_task)\\\\\n        self.habit = habit\\\\\n        self.bind_value(habit, "star")\\\\\n        self.props(f"checked-icon=\"", unchecked-icon=\"\", flat fab-mini keep-color color=grey-8")\\\\\n\\\\\n        self.refresh = refresh\\\\\n\\\\\n    async def _async_task(self, e: events.ValueChangeEventArguments):\\\\\n        self.habit.star = e.value\\\\\n        self.refresh()\\\\\n        logger.info(f"Habit Star changed to {e.value}")\\\\\n\\\\\nclass HabitDeleteButton(ui.button):\\\\\n    def __init__(self, habit: Habit, habit_list: HabitList, refresh: Callable) -> None:\\\\\n        super().__init__(on_click=self._async_task, icon=icons.DELETE)\\\\\n        self.habit = habit\\\\\n        self.habit_list = habit_list\\\\\n        self.refresh = refresh\\\\\n\\\\\n    async def _async_task(self):\\\\\n        await self.habit_list.remove(self.habit)\\\\\n        self.refresh()\\\\\n        logger.info(f"Deleted habit: {self.habit.name}")\\\\\n\\\\\nclass HabitAddButton(ui.input):\\\\\n    def __init__(self, habit_list: HabitList, refresh: Callable) -> None:\\\\\n        super().__init__("New item")\\\\\n        self.habit_list = habit_list\\\\\n        self.refresh = refresh\\\\\n        self.on("keydown.enter", self._async_task)\\\\\n        self.props("dense")\\\\\n\\\\\n    async def _async_task(self):\\\\\n        logger.info(f"Adding new habit: {self.value}")\\\\\n        await self.habit_list.add(self.value)\\\\\n        self.refresh()\\\\\n        self.set_value("")\\\\\n        logger.info(f"Added new habit: {self.value}")\\\\\n\\\\\nTODAY = "today"\\\\\n\\\\\nclass HabitDateInput(ui.date):\\\\\n    def __init__(self, today: datetime.date, habit: Habit, ticked_data: dict[datetime.date, bool]) -> None:\\\\\n        self.today = today\\\\\n        self.habit = habit\\\\\n        self.ticked_data = ticked_data\\\\\n        self.init = True\\\\\n        self.default_date = today\\\\\n        super().__init__(self.ticked_days, on_change=self._async_task)\\\\\n\\\\\n        self.props("multiple", "minimal", "flat", f"default-year-month={self.today.strftime(MONTH_MASK)}", f"first-day-of-week='{(settings.FIRST_DAY_OF_WEEK + 1) % 7}'", "today-btn")\\\\\n        self.classes("shadow-none")\\\\\n\\\\\n        self.bind_value_from(self, "ticked_days")\\\\\n\\\\\n    @property\\\\\n    def ticked_days(self) -> list[str]:\\\\\n        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\\\\\n        result.append(TODAY)\\\\\n        return result\\\\\n\\\\\n    async def _async_task(self, e: events.ValueChangeEventArguments):\\\\\n        old_values = set(self.habit.ticked_days)\\\\\n        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != TODAY)\\\\\n\\\\\n        for day in new_values - old_values:\\\\\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\\\\\n            self.ticked_data[day] = True\\\\\n            await self.habit.tick(day, True)\\\\\n            logger.info(f"QDate day {day} ticked: True")\\\\\n\\\\\n        for day in old_values - new_values:\\\\\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\\\\\n            self.ticked_data[day] = False\\\\\n            await self.habit.tick(day, False)\\\\\n            logger.info(f"QDate day {day} ticked: False")\\\\\n\\\\\n@dataclass\\\\\nclass CalendarHeatmap:\\\\\n    today: datetime.date\\\\\n    headers: list[str]\\\\\n    data: list[list[datetime.date]]\\\\\n    week_days: list[str]\\\\\n\\\\\n    @classmethod\\\\\n    def build(cls, today: datetime.date, weeks: int, firstweekday: int = calendar.MONDAY):\\\\\n        data = cls.generate_calendar_days(today, weeks, firstweekday)\\\\\n        headers = cls.generate_calendar_headers(data[0])\\\\\n        week_day_abbr = [calendar.day_abbr[(firstweekday + i) % 7] for i in range(7)]\\\\\n        return cls(today, headers, data, week_day_abbr)\\\\\n\\\\\n    @staticmethod\\\\\n    def generate_calendar_headers(days: list[datetime.date]) -> list[str]:\\\\\n        if not days:\\\\\n            return []\\\\\n        result = []\\\\\n        month = year = None\\\\\n        for day in days:\\\\\n            cur_month, cur_year = day.month, day.year\\\\\n            if cur_month != month:\\\\\n                result.append(calendar.month_abbr[cur_month])\\\\\n                month = cur_month\\\\\n                continue\\\\\n            if cur_year != year:\\\\\n                result.append(str(cur_year))\\\\\n                year = cur_year\\\\\n                continue\\\\\n            result.append("")\\\\\n        return result\\\\\n\\\\\n    @staticmethod\\\\\n    def generate_calendar_days(today: datetime.date, total_weeks: int, firstweekday: int = calendar.MONDAY) -> list[list[datetime.date]]:\\\\\n        lastweekday = (firstweekday - 1) % 7\\\\\n        days_delta = (lastweekday - today.weekday()) % 7\\\\\n        last_date_of_calendar = today + datetime.timedelta(days=days_delta)\\\\\n        return [\\\\\n            [last_date_of_calendar - datetime.timedelta(days=i, weeks=j) for j in reversed(range(total_weeks))] for i in reversed(range(WEEK_DAYS))]\\\\\n\\\\\nclass CalendarCheckBox(ui.checkbox):\\\\\n    def __init__(self, habit: Habit, day: datetime.date, today: datetime.date, ticked_data: dict[datetime.date, bool], is_bind_data: bool = True) -> None:\\\\\n        self.habit = habit\\\\\n        self.day = day\\\\\n        self.today = today\\\\\n        self.ticked_data = ticked_data\\\\\n        super().__init__("", value=self.ticked, on_change=self._async_task)\\\\\n\\\\\n        self.classes("inline-block")\\\\\n        self.props("dense")\\\\\n        unchecked_icon, checked_icon = self._icon_svg()\\\\\n        self.props(f"unchecked-icon=\"", checked-icon=\"")\\\\\n\\\\\n        if is_bind_data:\\\\\n            self.bind_value_from(self, "ticked")\\\\\n\\\\\n    @property\\\\\n    def ticked(self):\\\\\n        return self.ticked_data.get(self.day, False)\\\\\n\\\\\n    def _icon_svg(self):\\\\\n        unchecked_color, checked_color = "rgb(54,54,54)", "rgb(103,150,207)"\\\\\n        return (icons.SQUARE.format(color=unchecked_color, text=self.day.day), icons.SQUARE.format(color=checked_color, text=self.day.day))\\\\\n\\\\\n    async def _async_task(self, e: events.ValueChangeEventArguments):\\\\\n        self.ticked_data[self.day] = e.value\\\\\n        await self.habit.tick(self.day, e.value)\\\\\n        logger.info(f"Calendar Day {self.day} ticked: {e.value}")\\\\\n